{{- if not (has "grpc" (stencil.Arg "serviceActivities")) }}
{{ file.Skip "Not a gRPC service" }}
{{- end }}
{{- $_ := file.SetPath (printf "internal/%s/%s" .Config.Name (base file.Path)) }}
{{- $pkgName := stencil.ApplyTemplate "goPackageSafeName" }}
// {{ stencil.ApplyTemplate "copyright" }}

// Description: This file contains the gRPC server passthrough implementation for the
// {{ .Config.Name }} API defined in api/{{ .Config.Name }}.proto. The concrete implementation
// exists in the server.go file in this same directory.
// Managed: true

package {{ $pkgName }} //nolint:revive // Why: We allow [-_].

import (
	"context"
	"fmt"
	"net"

	"github.com/getoutreach/gobox/pkg/app"
	"github.com/getoutreach/gobox/pkg/events"
	"github.com/getoutreach/gobox/pkg/log"
	"github.com/getoutreach/gobox/pkg/trace"
	"github.com/getoutreach/{{ .Config.Name }}/api"
	"github.com/getoutreach/services/pkg/grpcx"
	"google.golang.org/grpc"
	"google.golang.org/grpc/reflection"

	{{- $additionalImports := stencil.GetModuleHook "internal/rpc/additionalImports" }}
	{{- if $additionalImports }}
	// imports added by modules
		{{- range $additionalImports }}
	{{ . | quote }}
		{{- end }}
	// end imports added by modules
	{{- end }}

	///Block(imports)
{{ file.Block "imports" }}
	///EndBlock(imports)
)

// GRPCService is the concrete implementation of the serviceActivity interface
// which defines methods to start and stop a service. In this case the service
// being implemented is a gRPC server.
type GRPCService struct {
	cfg *Config
}

// NewGRPCService creates a new GRPCService instance.
func NewGRPCService(cfg *Config) *GRPCService {
	return &GRPCService{cfg}
}

// Run starts a gRPC server.
//
//nolint:funlen // Why: This function is long for extensibility reasons since it is generated by stencil.
func (s *GRPCService) Run(ctx context.Context) error {
		lc := &net.ListenConfig{}
		listAddr := fmt.Sprintf("%s:%d", s.cfg.ListenHost, s.cfg.GRPCPort)
		lis, err := lc.Listen(ctx, "tcp", listAddr)
		if err != nil {
				log.Error(ctx, "failed to listen", events.NewErrorInfo(err))
				return err
		}
		defer lis.Close()

		var ops []grpcx.ServerOption
		// Initialize your server instance here.
		//
		///Block(server)
	{{- if file.Block "server" }}
{{ file.Block "server" }}
	{{- else }}
		server, err := NewServer(ctx, s.cfg)
		if err != nil {
				log.Error(ctx, "failed to create new server", events.NewErrorInfo(err))
				return err
		}
	{{- end }}
		///EndBlock(server)

		srv, err := StartServer(ctx, server, ops...)
		if err != nil {
				log.Error(ctx, "failed to start server", events.NewErrorInfo(err))
				return err
		}
		defer srv.Stop()

		// Shutdown the server when the context is canceled
		go func() {
				<-ctx.Done()
				srv.GracefulStop()
		}()

		// Note: .Serve() blocks
		log.Info(ctx, "Serving GRPC Service on "+listAddr)
		if err := srv.Serve(lis); err != nil {
			log.Error(ctx, "unexpected grpc Serve error", events.NewErrorInfo(err))
			return err
		}

		return nil
}

// Close closes the gRPC server.
func (s *GRPCService) Close(ctx context.Context) error {
	return nil
}

// StartServer starts a RPC server with the provided implementation.
func StartServer(ctx context.Context, service api.Service, opts... grpcx.ServerOption) (*grpc.Server, error) {
	{{- $grpcServerOptionInit := stencil.GetModuleHook "internal/rpc/grpcServerOptionInit" }}
	{{- if $grpcServerOptionInit }}
	// gRPC server option initialization injected by modules
		{{- range $grpcServerOptionInit }}
	{{ . }}

		{{- end }}
	// end gRPC server option initialization injected by modules
	{{- end }}

	opts = append([]grpcx.ServerOption{
		{{- $grpcServerOptions := stencil.GetModuleHook "internal/rpc/grpcServerOptions" }}
		{{- if $grpcServerOptions }}
		// gRPC server options injected by modules
			{{- range $grpcServerOptions }}
		{{ . }},
			{{- end }}
		// end gRPC server options injected by modules
		{{- end }}
	}, opts...)

	///Block(grpcServerOptions)
{{ file.Block "grpcServerOptions" }}
	///EndBlock(grpcServerOptions)

	s, err := grpcx.NewServer(ctx, opts...)
	if err != nil {
		return nil, err
	}

	{{- $additionalGRPCRPCS := stencil.GetModuleHook "internal/rpc/additionalGRPCRPCS" }}
	{{- if $additionalGRPCRPCS }}
	// gRPC RPCs injected by modules
		{{- range $additionalGRPCRPCS }}
	{{ . }}
		{{- end }}
	// end gRPC RPCs injected by modules
	{{- end }}

	// Register service
	api.Register{{ title $pkgName }}Server(s, rpcserver{service})

	// Register reflection
	reflection.Register(s)

	return s, nil
}

// rpcserver is a shim that converts the generic Service interface
// into the grpc generated interface from the protobuf
type rpcserver struct {
	api.Service
}

// Place any GRPC handler functions for your service here
//
///Block(handlers)
{{- if file.Block "handlers" }}
{{ file.Block "handlers" }}
{{- else }}

// Ping is a simple ping/pong handler.
func (s rpcserver) Ping(ctx context.Context, req *api.PingRequest) (*api.PingResponse, error) {
	message, err := s.Service.Ping(ctx, req.Message)
	if err != nil {
		return nil, err
	}
	return &api.PingResponse{Message: message}, nil
}

// Pong is a simple RPC that returns a message.
func (s rpcserver) Pong(ctx context.Context, req *api.PongRequest) (*api.PongResponse, error) {
	message, err := s.Service.Pong(ctx, req.Message)
	if err != nil {
		return nil, err
	}
	return &api.PongResponse{Message: message}, nil
}

{{- $additionalDefaultHandlers := stencil.GetModuleHook "internal/rpc/additionalDefaultHandlers" }}
{{- range $additionalDefaultHandlers }}
{{ . }}

{{- end }}
{{- end }}
///EndBlock(handlers)
